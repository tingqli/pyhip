# asm JIT

基于inline-asm的JIT，跟真正的jit不同，inline-asm是一种文本形式的代码，因此其本身就具有IR的特点，所以在生成最终asm源码之前有很多变换的可能。

使用Jit书写程序跟使用高级语言存在一个非常重大的区别：Jit有两种语言分别描述编译期行为和运行期行为，其中宿主语言(此处是Python, Xbyak是C++)负责描述编译期逻辑，也就是为了完成最终运行时行为而针对性构造代码的逻辑，而运行期语言（此处是AMDGPU汇编+一些高级语法糖, Xbyak是x86/arm64纯汇编）则是描述运行期行为。 直接使用CUDA/HIP高级语言中的模板(meta-programming)能够完成类似效果，但是比较晦涩。

这些特性是叠加式的不是全部都ready整个系统才可用

# 寄存器手动分配/释放

寄存器手动分配/释放,可以指定寄存器名，或者不指定自动分配
这是个编译期伪指令

```python
        kernel_args = J.new_gpr("s",[0,1])
        threadIdx_X = J.new_gpr("v",[0])
        temp = J.new_gpr("v", 6)    # 
```

# 寄存器生命周期自动维护

上面的方案中，所分配的寄存器索引会一直增加，没有释放行为。这对于需要使用临时变量的情况非常不友好，jit编写者需要花费很大精力维护。

线性扫描：
 - https://anoopsarkar.github.io/compilers-class/assets/lectures/opt3-regalloc-linearscan.pdf
 - https://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf

基于上面的文档，该方法简单的扫描IR的指令确定寄存器的生命周期，需要注意，首先找到live range然后找到live interval：

 - live range是寄存器的一写(发生在t0时刻)一读(发生在t1时刻)之间的距离`t0~t1`，假设未来t2时刻又写入该寄存器的话，则`t1~t2`期间其实不需要该寄存器活跃，可以直接释放该寄存器做其他用途，而t2时刻的写也可以分配新寄存器，不一定非得用相同的该寄存器。表现在coding上就是程序员每次需要生成临时变量的时候，可以直接分配新的，不需要考虑复用之前已经分配过的某个变量。

 - 得到生命周期还需要一个映射，因为编译期不能确定执行流的确切次序，只能得到指令排布次序，用这个排布次序近似时间次序。这种近似不会引起正确性问题。另外BB的排列次序在书写jit代码时就确定了，因此每条指令根据BB次序就分配得到了一个天然的serial序列号(sid)

 - 如果循环体bb0使用寄存器a，则因为bb0会跳转回bb0，整个循环体都是a的live-range；扩展这个规则就是，如果代码执行路径未来有可能还会访问寄存器a，则a的活跃范围至少需要扩充到本bb的末尾。而如何知道未来是否会访问a？一个简单的方式是检查bb的predecessors, 如果存在祖先BB的sid更大，也就是来自未来的跳转发生了，那么当前bb的起点到这个未来跳转之间看似结束使用的寄存器则都应该扩展其生命周期到祖先的跳转指令处，从而延长其寿命保证循环跳转范围内其值一直有效。 
 
 - if/else分支，如果两个分支中只有一个**最后一次**使用了某个寄存器，另一个分支没用该寄存器，则根据IR次序的最后一次使用点就是该寄存器的生命周期终结点；不论代码生成时if分支地址在前面还是else分支地址在前面。都可以这样计算其生命周期。


# 简单表达式

可以视为一种汇编助记符的扩展，例如加减乘，移位，与/或等指令,但是要想生成正确的指令，还需要知道寄存器类型，数据类型等信息。这些信息在高级语言中存在，但是在JIT中却没有，除非我们直接引入寄存器变量概念，变量就具有类型，就能生成正确的指令。

如果对无类型的寄存器施加表达式，jit可以直接报错，也就是说类型信息是可选的。只有使用表达式时才会参考类型信息。
类型指的就是一个寄存器的类型，包括i32/u32/i16/u16/f32/f16/pkf16(两个f16 packed)等，暂时忽略u64/i64等类型。

```python
a = J.var("s", "u64", 3)
a = J.var("s", "u32")    #缺省1个u32
a = J.var("s", "u32", 4) #4个u32  a[0],a[1],...,a[3], a[0:1], a[2:3]
v1 = J.var("v", "f32", 4)
v2 = J.var("v", "u32", 4)

v1[0] = v1[0] + v1[1]  # v_add_f32(v[0], v[0], v[1])
v2[0] = v2[0] + v2[1]  # v_add_u32(v[0], v[0], v[1])

# 更复杂的表达式会jit生成多条Instruction, 并且可能内部申请临时变量，但是有了寄存器自动维护，这都不是问题
# 例如下面的代码，但是要想实现公共表达式消除等高级功能，则需要对多个表达式同时分析，也就是在运行到这条语句
# 时并不生成instruction，而是插入一个特殊占位符指令，在全部jit运行完毕之后，这些占位符指令记录下来的表达式
# 就能被统一优化并生成instruction序列。
# 能够进行公共表达式优化的都必须在一个基本块内部。
# 复杂表达式先被拆分为简单表达式，然后查找公共
v2[0] = v2[0] + (v2[1] & 0x60)<<2

```

# control flow

比较表达式有一些特殊，因为其结果存放于特殊flag寄存器(scc/vcc)中：

 - 结果可以参与运算,可以使用一些指令转换结果:
```s
    s_mov_b32 dst, scc 
    s_cselect_b64 vcc, -1, 0
    S_CSELECT_{B32, B64}    SOP2 n  D = SCC ? S0 : S1.
    S_CMOVK_I32             SOPK n  if (SCC) D = signext(simm16).
    S_CMOV_{B32,B64}        SOP1 n  if (SCC) D = S0, else NOP.

    v_cndmask_b32_e64 v1, 0, 1, vcc
    v_addc_co_u32_e32 
```
 - 直接控制跳转则不需要如此，直接利用scc/vcc即可： S_CBRANCH_SCC0/S_CBRANCH_SCC1

为了简化逻辑，我们可以总是把比较表达式的结果转移到通用寄存器中，如果这个表达式给跳转使用的话，则再次使用s_cmp_eq等方式转换回scc
然后再最后如果整个表达式是给 S_CBRANCH_SCC1 使用，则检查是否末尾指令存在把scc转换到某个通用寄存器再换回来的情况，是的话就优化掉
或者在生成过程中最后一步如果结果已经在scc中，并且正在为`Jump`语法糖生成代码，就不用再转换到通用寄存器中了。

当然这只对使用表达式的情况，编程者总是可以退回到纯汇编来避免不优化的代码被生成。

```python

# 循环体不等效于基本块，因为循环内也可能有跳转分支，所以循环体完全可能由多个基本块组成
# 严格来说汇编中不存在循环体的等效概念，随意跳转
# 使用下面的逻辑可以很容易的模仿for/while loop

# ... prelog
J.Label("loop_start")
# break if condition is true
J.Jump("loop_ends", (a[0]*32 + 5) >= b[0])

# ... loop_body

J.Jump("loop_start") # jump back
J.Label("loop_ends")


# 在此基础上包装一下下面的语法糖, 该语法糖在进入和退出时生成上面的代码
with J.While((a[0]*32 + 5) >= b[0]):
    # ... loop_body


# if/else逻辑：
J.JumpNot("else_body", (a[0]*32 + 5) >= b[0])
... # if body
J.Jump("if_else_end")
J.Label("else_body")
... # else body
J.Label("if_else_end")

# 在此基础上包装一下下面的语法糖，假设
with J.If((a[0]*32 + 5) >= b[0]) as branch:
    ... # if body
    branch.Else() # 生成 jump到结尾和else-body的代码
    ...# else body

# 综合来看，复杂表达式/Label/Jump/While/If构造可以极大简化汇编代码书写
```

# 单元测试
复杂的jit逻辑需要单元测试保证正确性：
 - 类似LLVM那样直接检查最终汇编代码是否符合预期，这种检查可以使用特殊jit指令完成，无需invoke后端编译工具
 - 也可以实际运行代码看运行结果是否符合预期，测试用例需要读入数据，执行某些操作，写回数据，由host检查结果正确性

```bash
pytest unittest/
```



# 表达式解析
    公共表达式提取---留给手工优化

    简单表达式直接emit对应指令：例如v2=s3, v2=v2>>2，但是这里有个问题，
    =无法被python执行重载，因此必须使用v[2]=,或者v[...]= 或者v[:]=

    简单表达式+寄存器自动分配： v2=J.new_gpr((v2>>2)+v3), 因为有寄存器自动分配逻辑，每次形成新值
    这样表达式写起来更加简单，无需额外的寄存器分配步骤 (v2>>2)+v3 这样的表达式自动被寄存器类型捕获
    当然这样也需要知道v2/v3的类型，因此指令操作的是有类型变量，

    acc=J.var(16*16, dtype="I32", reg="v")

    这样的语句就是寄存器分配伪指令，伪指令的作用是编译期，指导编译期行为的

    acc=J.var(v2>>2 + 4)

    这样的语句就是表达式赋值+寄存器分配伪指令


有了表达式的帮助，可以实现简单(per-warp)的loop或者if/else分支:

    with J._while(v2 < CNT) as bb:
        v2 = J.var(v2 + 1)

        with J._if(v2 > 7):
            bb.break()

    基于contextmanager的方式，enter之后就会开始捕获后继的指令序列作为BB的内容，这样方便在合适的地方插入循环结束判断条件
    但是循环内更新变量赋值的行为可能造成问题，因为这将制造新变量，但是其实我们想更新旧变量，此时需要使用v2[:]=v2+1这样的赋值
    才能正确表达我们的意思，另外表达式的引入可能造成无法区分编译期代码和执行期代码，需要辨别

    类似bb.break这样的代码也会被捕获

    允许变量赋值意味着放弃SSA, 