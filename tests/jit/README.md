# asm JIT

这些特性是叠加式的不是全部都ready整个系统才可用

# 寄存器手动分配/释放

寄存器手动分配/释放,可以指定寄存器名，或者不指定自动分配
这个是编译期伪指令:

```python
        kernel_args = J.new_gpr("s",[0,1])
        threadIdx_X = J.new_gpr("v",[0])
        temp = J.new_gpr("v", 6)    # 
        del temp                    # 显式释放（可选）,不释放就一直有效
```
动态分配基于内部维护的寄存器资源表完成

# 简单表达式

可以视为一种汇编助记符的扩展，例如加减乘，移位，与/或等指令：
```
 sdst[...] = ssrc0 << ssrc1
 s_lshl_b32 sdst,   ssrc0,     ssrc1:u32

```
# 寄存器生命周期自动维护

上面的方案中，所分配的寄存器索引会一直增加，没有释放行为。这对于计算表达式需要一些临时变量的情况非常不友好，如果寄存器生命周期能够基于引用计数自动维护，类似python那样就可以极大的提高生产率。而且这种自动维护没任何副作用（指定寄存器范围的“预留”静态分配功能仍然生效，引用范围内不会有人释放）。

在上面的方案基础上，增加一个后处理pass，遍历代码基本块，统计动态寄存器的生命周期，然后根据生命周期，重用非静态预留的寄存器。这可以视为一个能够压缩寄存器使用率的附加pass

初始执行: emit代码序列+寄存器占位符
分配寄存器：根据代码序列分析寄存器生命周期，映射物理寄存器

分析生命周期需要知道BasicBlock的执行次序，编译期无法预计运行期跳转是否会执行，因此跳转还是不跳转
的BB接续者BB都是潜在延长寄存器生命周期的。

第一次进入BB时，就可以确定BB访问了哪些之前定义过，赋值过的寄存器，从而延长他们的生命周期到本BB最后一次访问
但是如果未来跳转目的BB（这个跳转目的包括自身）仍然会访问这个寄存器，则其生命周期将会需要进一步延长到本BB末尾。
如果未来所有跳转目的BB都不再访问此寄存器，则可以确定此寄存器生命周期就是本BB的最后一次访问，插入一个显式的寄存器释放伪指令

分析完生命周期，就可以映射物理寄存器，当前BB中的伪指令按顺序执行就可以分配释放，后继BB中的


# 表达式解析
    公共表达式提取---留给手工优化

    简单表达式直接emit对应指令：例如v2=s3, v2=v2>>2，但是这里有个问题，
    =无法被python执行重载，因此必须使用v[2]=,或者v[...]= 或者v[:]=

    简单表达式+寄存器自动分配： v2=J.new_gpr((v2>>2)+v3), 因为有寄存器自动分配逻辑，每次形成新值
    这样表达式写起来更加简单，无需额外的寄存器分配步骤 (v2>>2)+v3 这样的表达式自动被寄存器类型捕获
    当然这样也需要知道v2/v3的类型，因此指令操作的是有类型变量，

    acc=J.var(16*16, dtype="I32", reg="v")

    这样的语句就是寄存器分配伪指令，伪指令的作用是编译期，指导编译期行为的

    acc=J.var(v2>>2 + 4)

    这样的语句就是表达式赋值+寄存器分配伪指令


有了表达式的帮助，可以实现简单(per-warp)的loop或者if/else分支:

    with J._while(v2 < CNT) as bb:
        v2 = J.var(v2 + 1)

        with J._if(v2 > 7):
            bb.break()

    基于contextmanager的方式，enter之后就会开始捕获后继的指令序列作为BB的内容，这样方便在合适的地方插入循环结束判断条件
    但是循环内更新变量赋值的行为可能造成问题，因为这将制造新变量，但是其实我们想更新旧变量，此时需要使用v2[:]=v2+1这样的赋值
    才能正确表达我们的意思，另外表达式的引入可能造成无法区分编译期代码和执行期代码，需要辨别

    类似bb.break这样的代码也会被捕获

    允许变量赋值意味着放弃SSA, 