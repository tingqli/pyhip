# asm JIT

基于inline-asm的JIT，跟真正的jit不同，inline-asm是一种文本形式的代码，因此其本身就具有IR的特点，所以在生成最终asm源码之前有很多变换的可能。

这些特性是叠加式的不是全部都ready整个系统才可用

# 寄存器手动分配/释放

寄存器手动分配/释放,可以指定寄存器名，或者不指定自动分配
这是个编译期伪指令

```python
        kernel_args = J.new_gpr("s",[0,1])
        threadIdx_X = J.new_gpr("v",[0])
        temp = J.new_gpr("v", 6)    # 
```

# 寄存器生命周期自动维护

上面的方案中，所分配的寄存器索引会一直增加，没有释放行为。这对于需要使用临时变量的情况非常不友好，jit编写者需要花费很大精力维护。

线性扫描：
 - https://anoopsarkar.github.io/compilers-class/assets/lectures/opt3-regalloc-linearscan.pdf
 - https://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf

基于上面的文档，该方法简单的扫描IR的指令确定寄存器的生命周期，需要注意，首先找到live range然后找到live interval：

 - live range是寄存器的一写(发生在t0时刻)一读(发生在t1时刻)之间的距离`t0~t1`，假设未来t2时刻又写入该寄存器的话，则`t1~t2`期间其实不需要该寄存器活跃，可以直接释放该寄存器做其他用途，而t2时刻的写也可以分配新寄存器，不一定非得用相同的该寄存器。表现在coding上就是程序员每次需要生成临时变量的时候，可以直接分配新的，不需要考虑复用之前已经分配过的某个变量。

 - 得到生命周期还需要一个映射，因为编译期不能确定执行流的确切次序，只能得到指令排布次序，用这个排布次序近似时间次序。这种近似不会引起正确性问题。另外BB的排列次序在书写jit代码时就确定了，因此每条指令根据BB次序就分配得到了一个天然的serial序列号(sid)

 - 如果循环体bb0使用寄存器a，则因为bb0会跳转回bb0，整个循环体都是a的live-range；扩展这个规则就是，如果代码执行路径未来有可能还会访问寄存器a，则a的活跃范围至少需要扩充到本bb的末尾。而如何知道未来是否会访问a？一个简单的方式是检查bb的predecessors, 如果存在祖先BB的sid更大，也就是来自未来的跳转发生了，那么当前bb的起点到这个未来跳转之间看似结束使用的寄存器则都应该扩展其生命周期到祖先的跳转指令处，从而延长其寿命保证循环跳转范围内其值一直有效。 
 
 - if/else分支，如果两个分支中只有一个**最后一次**使用了某个寄存器，另一个分支没用该寄存器，则根据IR次序的最后一次使用点就是该寄存器的生命周期终结点；不论代码生成时if分支地址在前面还是else分支地址在前面。都可以这样计算其生命周期。


# 简单表达式

可以视为一种汇编助记符的扩展，例如加减乘，移位，与/或等指令,但是要想生成正确的指令，还需要知道寄存器类型，数据类型等信息。这些信息在高级语言中存在，但是在JIT中却没有，除非我们直接引入寄存器变量概念，变量就具有类型，就能生成正确的指令。

如果对无类型的寄存器施加表达式，jit可以直接报错，也就是说类型信息是可选的。只有使用表达式时才会参考类型信息。
类型指的就是一个寄存器的类型，包括i32/u32/i16/u16/f32/f16/pkf16(两个f16 packed)等，暂时忽略u64/i64等类型。

```python
a = J.var("s", "u64", 3)
a = J.var("s", "u32")    #缺省1个u32
a = J.var("s", "u32", 4) #4个u32  a[0],a[1],...,a[3], a[0:1], a[2:3]
v1 = J.var("v", "f32", 4)
v2 = J.var("v", "u32", 4)

v1[0] = v1[0] + v1[1]  # v_add_f32(v[0], v[0], v[1])
v2[0] = v2[0] + v2[1]  # v_add_u32(v[0], v[0], v[1])

# 更复杂的表达式会jit生成多条Instruction, 并且可能内部申请临时变量，但是有了寄存器自动维护，这都不是问题
# 例如下面的代码，但是要想实现公共表达式消除等高级功能，则需要对多个表达式同时分析，也就是在运行到这条语句
# 时并不生成instruction，而是插入一个特殊占位符指令，在全部jit运行完毕之后，这些占位符指令记录下来的表达式
# 就能被统一优化并生成instruction序列。
# 能够进行公共表达式优化的都必须在一个基本块内部。
# 复杂表达式先被拆分为简单表达式，然后
v2[0] = v2[0] + (v2[1] & 0x60)<<2

```

```
 sdst[...] = ssrc0 << ssrc1
 s_lshl_b32 sdst,   ssrc0,     ssrc1:u32
```

# 表达式解析
    公共表达式提取---留给手工优化

    简单表达式直接emit对应指令：例如v2=s3, v2=v2>>2，但是这里有个问题，
    =无法被python执行重载，因此必须使用v[2]=,或者v[...]= 或者v[:]=

    简单表达式+寄存器自动分配： v2=J.new_gpr((v2>>2)+v3), 因为有寄存器自动分配逻辑，每次形成新值
    这样表达式写起来更加简单，无需额外的寄存器分配步骤 (v2>>2)+v3 这样的表达式自动被寄存器类型捕获
    当然这样也需要知道v2/v3的类型，因此指令操作的是有类型变量，

    acc=J.var(16*16, dtype="I32", reg="v")

    这样的语句就是寄存器分配伪指令，伪指令的作用是编译期，指导编译期行为的

    acc=J.var(v2>>2 + 4)

    这样的语句就是表达式赋值+寄存器分配伪指令


有了表达式的帮助，可以实现简单(per-warp)的loop或者if/else分支:

    with J._while(v2 < CNT) as bb:
        v2 = J.var(v2 + 1)

        with J._if(v2 > 7):
            bb.break()

    基于contextmanager的方式，enter之后就会开始捕获后继的指令序列作为BB的内容，这样方便在合适的地方插入循环结束判断条件
    但是循环内更新变量赋值的行为可能造成问题，因为这将制造新变量，但是其实我们想更新旧变量，此时需要使用v2[:]=v2+1这样的赋值
    才能正确表达我们的意思，另外表达式的引入可能造成无法区分编译期代码和执行期代码，需要辨别

    类似bb.break这样的代码也会被捕获

    允许变量赋值意味着放弃SSA, 